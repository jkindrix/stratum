// ---------------------------------------------------------------------------
// Stratum — L-System (Lindenmayer System) Generators
// ---------------------------------------------------------------------------

/** A production rule for the L-system. */
export interface ProductionRule {
  /** The single character to match. */
  readonly predecessor: string;
  /** Optional left-context character for context-sensitive matching. */
  readonly leftContext?: string;
  /** Optional right-context character for context-sensitive matching. */
  readonly rightContext?: string;
  /** The replacement string produced by this rule. */
  readonly successor: string;
}

/** Mapping from symbols to musical parameters. */
export interface SymbolMapping {
  /** Map from symbol character to pitch class (0-11). */
  readonly pitch?: ReadonlyMap<string, number>;
  /** Map from symbol character to duration in ticks. */
  readonly rhythm?: ReadonlyMap<string, number>;
}

/** A musical event generated by an L-system. */
export interface LSystemEvent {
  /** Pitch class (0-11). */
  readonly pitchClass: number;
  /** Duration in ticks. */
  readonly duration: number;
  /** Position index in the generated sequence. */
  readonly index: number;
}

/** Default pitch mapping: note letters to pitch classes. */
export const PITCH_MAPPING: ReadonlyMap<string, number> = Object.freeze(
  new Map<string, number>([
    ['C', 0], ['D', 2], ['E', 4], ['F', 5],
    ['G', 7], ['A', 9], ['B', 11],
    ['c', 0], ['d', 2], ['e', 4], ['f', 5],
    ['g', 7], ['a', 9], ['b', 11],
  ]),
);

/** Default rhythm mapping: common duration symbols. */
export const RHYTHM_MAPPING: ReadonlyMap<string, number> = Object.freeze(
  new Map<string, number>([
    ['w', 1920], // whole
    ['h', 960],  // half
    ['q', 480],  // quarter
    ['e', 240],  // eighth
    ['s', 120],  // sixteenth
  ]),
);

/**
 * Lindenmayer system for generating fractal/self-similar musical sequences.
 *
 * Supports both context-free rules (only predecessor) and context-sensitive
 * rules (with optional left/right context). Context-sensitive rules are
 * checked first and take priority.
 *
 * @example
 * ```ts
 * // Classic Algae L-system: A→AB, B→A
 * const ls = new LSystem('A', [
 *   { predecessor: 'A', successor: 'AB' },
 *   { predecessor: 'B', successor: 'A' },
 * ]);
 * ls.iterate(5); // "ABAABABAABAAB"
 * ```
 */
export class LSystem {
  /** The starting string. */
  readonly axiom: string;
  /** Production rules. */
  readonly rules: readonly ProductionRule[];

  /** Context-sensitive rules (have leftContext or rightContext). */
  private readonly contextRules: readonly ProductionRule[];
  /** Context-free rules (no context). */
  private readonly freeRules: readonly ProductionRule[];

  /**
   * Create a new L-system.
   *
   * @param axiom - The initial string (must not be empty).
   * @param rules - Production rules.
   * @throws {RangeError} If axiom is empty or any predecessor is not a single character.
   */
  constructor(axiom: string, rules: readonly ProductionRule[]) {
    if (axiom.length === 0) {
      throw new RangeError('axiom must not be empty');
    }
    for (const rule of rules) {
      if (rule.predecessor.length !== 1) {
        throw new RangeError(
          `predecessor must be a single character (got "${rule.predecessor}")`,
        );
      }
    }

    this.axiom = axiom;
    this.rules = rules;

    // Partition rules by context sensitivity
    const ctx: ProductionRule[] = [];
    const free: ProductionRule[] = [];
    for (const rule of rules) {
      if (rule.leftContext !== undefined || rule.rightContext !== undefined) {
        ctx.push(rule);
      } else {
        free.push(rule);
      }
    }
    this.contextRules = ctx;
    this.freeRules = free;
  }

  /**
   * Apply production rules n times.
   *
   * @param n - Number of iterations (must be ≥ 0).
   * @returns The resulting string after n iterations.
   * @throws {RangeError} If n < 0.
   */
  iterate(n: number): string {
    if (!Number.isInteger(n) || n < 0) {
      throw new RangeError(`iterations must be a non-negative integer (got ${n})`);
    }

    let current = this.axiom;
    for (let iter = 0; iter < n; iter++) {
      let next = '';
      for (let i = 0; i < current.length; i++) {
        const ch = current[i]!;
        const left = i > 0 ? current[i - 1]! : '';
        const right = i < current.length - 1 ? current[i + 1]! : '';

        let matched = false;

        // Check context-sensitive rules first
        for (const rule of this.contextRules) {
          if (rule.predecessor !== ch) continue;
          if (rule.leftContext !== undefined && rule.leftContext !== left) continue;
          if (rule.rightContext !== undefined && rule.rightContext !== right) continue;
          next += rule.successor;
          matched = true;
          break;
        }

        if (!matched) {
          // Check context-free rules
          for (const rule of this.freeRules) {
            if (rule.predecessor === ch) {
              next += rule.successor;
              matched = true;
              break;
            }
          }
        }

        // Identity: pass through if no rule matches
        if (!matched) {
          next += ch;
        }
      }
      current = next;
    }
    return current;
  }

  /**
   * Generate a musical event sequence from the L-system output.
   *
   * Iterates the system and maps each character through the provided
   * symbol mappings. Characters not found in any mapping are skipped.
   *
   * @param mapping - Symbol-to-music mappings.
   * @param iterations - Number of L-system iterations (default 1).
   * @returns Frozen array of LSystemEvent objects.
   */
  toSequence(mapping: SymbolMapping, iterations: number = 1): readonly LSystemEvent[] {
    const str = this.iterate(iterations);
    const events: LSystemEvent[] = [];
    let idx = 0;

    for (let i = 0; i < str.length; i++) {
      const ch = str[i]!;
      const pc = mapping.pitch?.get(ch);
      const dur = mapping.rhythm?.get(ch);

      // Skip if character has no mapping at all
      if (pc === undefined && dur === undefined) continue;

      events.push(
        Object.freeze({
          pitchClass: pc ?? 0,
          duration: dur ?? 480,
          index: idx,
        }),
      );
      idx++;
    }

    return Object.freeze(events);
  }
}
